# -*- coding: utf-8 -*-
"""Mancala.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15xFHdK72t43-Dc9JTBfES0saeI6fqeqW
"""

import numpy as np


def InitialBoard():
    # 6 pits for each player and 1 Mancala for each player
    # Board is represented as [Player1's pits, Player1's Mancala, Player2's pits, Player2's Mancala]
    return [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]


def getLegalMoves(B, p):
    # Returns a list of legal moves for player p
    # A move is represented by the index of the pit the player chooses to start from
    if p == 1:
        return [i for i in range(6) if B[i] > 0]
    else:
        return [i for i in range(7, 13) if B[i] > 0]


def UpdateBoard(B, move):
    seeds = B[move]
    B[move] = 0
    i = move
    while seeds > 0:
        i = (i + 1) % 14
        if (move < 7 and i == 13) or (move > 6 and i == 6):  # Skip opponent's Mancala
            continue
        B[i] += 1
        seeds -= 1

    # Check for capture
    if (move < 7 and i < 6 and B[i] == 1) or (move > 6 and 6 < i < 13 and B[i] == 1):
        opposite_pit = 12 - i
        if B[opposite_pit] > 0:
            B[6 if move < 7 else 13] += B[i] + B[opposite_pit]
            B[i], B[opposite_pit] = 0, 0

    # Determine next player
    if (move < 7 and i == 6) or (
        move > 6 and i == 13
    ):  # If last seed lands in player's Mancala
        return move // 7 + 1
    return 3 - (move // 7 + 1)


def printBoard(B):
    # B: [Player1's pits, Player1's Mancala, Player2's pits, Player2's Mancala]
    print("Player 2")
    print("Mancala: ", B[13])
    print("Pits:    ", B[12], B[11], B[10], B[9], B[8], B[7])
    print("-----------------------------")
    print("Pits:    ", B[0], B[1], B[2], B[3], B[4], B[5])
    print("Mancala: ", B[6])
    print("Player 1")


def isGameOver(B):
    # Check if all pits on Player 1's side are empty
    if sum(B[:6]) == 0:
        # Move all seeds from Player 2's pits to their Mancala
        B[13] += sum(B[7:13])
        for i in range(7, 13):
            B[i] = 0
        gameOver = True
    # Check if all pits on Player 2's side are empty
    elif sum(B[7:13]) == 0:
        # Move all seeds from Player 1's pits to their Mancala
        B[6] += sum(B[:6])
        for i in range(6):
            B[i] = 0
        gameOver = True
    else:
        gameOver = False

    if gameOver:
        if B[6] > B[13]:
            return True, 1
        elif B[6] < B[13]:
            return True, 2
        else:
            return True, 0  # It's a tie
    else:
        return False, None


# Test
def play_game():
    gameOver = False
    B = InitialBoard()
    next_player = 1
    rounds = 0
    while False is gameOver:
        rounds += 1
        # printBoard(B)
        moves = getLegalMoves(B, next_player)
        move = np.random.choice(moves)
        # print("\nNext player to move:", next_player, "chooses move:", move, "possible moves:", moves)
        next_player = UpdateBoard(B, move)  # takes the first legal move
        gameOver, winningPlayer = isGameOver(B)

    return rounds

    # print("Final board:")
    # printBoard(B)
    # if winningPlayer == 0:
    #     print("Its a draw! ", winningPlayer)
    # else:
    #     print("The winning player is: ", winningPlayer)


# rounds = 0
# for i in range(1000):
#     rounds += play_mancala()

# rounds/ 1000
